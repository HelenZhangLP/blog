<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.20/lodash.core.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/raphael/2.3.0/raphael.min.js"></script>
  
  <title>
    react 组件 |
    
    女魔头</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-react-component" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      react 组件
    </h1>
  


      </header>
    

    
      <div class="article-meta">
        <a href="/2020/11/29/react-component/" class="article-date">
  <time datetime="2020-11-29T11:43:42.000Z" itemprop="datePublished">2020-11-29</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h2 id="组件的-state"><a href="#组件的-state" class="headerlink" title="组件的 state"></a>组件的 state</h2><ol>
<li>state 设计的几点原则；</li>
<li>正确修改 state;<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2></li>
<li>组件在 componentDidMount 中与服务器通信</li>
<li>父子组件与兄弟组件通信</li>
</ol>
<a id="more"></a>
<h2 id="组件的-state-1"><a href="#组件的-state-1" class="headerlink" title="组件的 state"></a>组件的 state</h2><h3 id="适合的-state"><a href="#适合的-state" class="headerlink" title="适合的 state"></a>适合的 state</h3><ul>
<li><p>state 代表一个组件 UI 呈现的完整状态集</p>
<ul>
<li>渲染组件时所用到的数据的来源</li>
<li>用作组件 UI 展现形式的判断依据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">pop</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// construct 用于初始化组件的 state及绑定事件</span></span><br><span class="line">  construct(props) &#123;</span><br><span class="line">    <span class="comment">// 调用父类的 construct 方法，即调用 react.Component 的构造方法。用于完成 react 组件的初始化工作，保证 props 传入组件</span></span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isShow: <span class="literal">false</span>, <span class="comment">// 展现形式的判断依据</span></span><br><span class="line">      pop: <span class="string">'弹层'</span> <span class="comment">// 渲染时所用到的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;isShow, pop&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      isShow ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;pop&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>state 代表一个组件 UI 呈现的最小状态集，state 中所有的状态都用于反映组件 ui 变化，没有任何多余的状态，也不应该存在通过其他状态计算而来的中间状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">purchaseCart</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  construct(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// 错误的 state 案例</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      purchaseList: [],</span><br><span class="line">      totalCost: <span class="number">0</span> <span class="comment">// 根据 purchaseList 中 的 price 计算得来的，属性于中间多余属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="demo-显示当前组件并每秒钟更新"><a href="#demo-显示当前组件并每秒钟更新" class="headerlink" title="demo 显示当前组件并每秒钟更新"></a><code>demo 显示当前组件并每秒钟更新</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">timer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  construct(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.timer = <span class="literal">null</span>; <span class="comment">// 非 props 或 state，是一个普通属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDitMount() &#123;</span><br><span class="line">    <span class="comment">// timer 不用于渲染</span></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        date: newDate()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">      clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.state.date.toString()&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>触发沉浸的属性是 props 和 state，props 来自父级，只读属性，不能修改。如果需要修改须在父级 setState 修改，state 维护组件内部属性。</p>
</blockquote>
<ol>
<li>变量是否从 props 中获取，若是，则不是一个状态；</li>
<li>变量是否在组件的整个生命周期中保持不变，若是，则不是一个状态；</li>
<li>状态是否是从在组件 render 中使用，未使用，则不是一个状态，适合用普通属性。</li>
</ol>
<h3 id="正确修改-state"><a href="#正确修改-state" class="headerlink" title="正确修改 state"></a>正确修改 state</h3><p>state 需要通过 setState 修改，<code>this.state.name = &#39;helen&#39;</code> 不会触发 render 渲染</p>
<blockquote>
<p>不要依赖当前的 state 计算下一个 state，<code>state 更新是异步的</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object.assign(&#123;</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;<span class="attr">quantity</span>: <span class="keyword">this</span>.state.quantity + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">quantity</span>: <span class="keyword">this</span>.state.quantity + <span class="number">1</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如上 React出于性能原因，会把多次的 state 修改合并成一次，也就是说组件的 state 并不是调用 setState 时立即修改的，而是把要修改的状态合并到一个队列中一次执行。应付造成，quantity 只加了一次，而不是设计的加 2。正确的修改方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  quantity: preState.quantity + <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>preState 当前更新状态的前一个状态，props 当前最新的 props</p>
<p>state 更新是一个合并的过程，调用 setState 修改组件时，只需要传入发生改变的 state，react 会把修改的 state 与原 state 合并，未修改的保持不变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state = &#123;...this.state, &#123;<span class="attr">title</span>: <span class="string">'modify title'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="react-官方建议把-state-当作不可变对象"><a href="#react-官方建议把-state-当作不可变对象" class="headerlink" title="react 官方建议把 state 当作不可变对象"></a>react 官方建议把 state 当作不可变对象</h3><p>state 中包含的所有状态都应该是不可变对象，state 中的某个状态发生变化时，应该重新创建这个状态对象，并非是修改原来的状态。将状态类型分为三种情况创建新的状态对象：</p>
<ol>
<li><p>状态类型是数字、字符串、布尔值、null、undefined<br>直接给修改状态赋新值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  quantity: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'react'</span>,</span><br><span class="line">  success: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态类型是数组</p>
<blockquote>
<p>状态发生变化时重新创建状态对象，数组方法中，push, pop, shift, unshift, splice 都是 <code>在原数组的基础上修改的</code>，concat、slice、filter 是<code>返回一个新数组</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* books 是要修改的状态，类型为数组 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 preState、concat 创建新数组</span></span><br><span class="line"><span class="comment">// 箭头之后的圆括号用来实现换行（MDN）</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.concat([<span class="string">'react guide'</span>])</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 spread syntax</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> (&#123;</span><br><span class="line">  books: [...preState.books, <span class="string">'react guide'</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>用 <code>slice</code> 从数组中截取一部分元素作为新状态；用<code>filter</code> 过滤部分元素作作为新状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.slice(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item !== <span class="string">'react'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>状态类型是不包含字符串、数组的普通对象<br>避免修改原对象的方法，使用返回一个新对象的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ES6 Object.assgin 方法</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  owner: <span class="built_in">Object</span>.assgin(&#123;&#125;, preState.owner, &#123;<span class="attr">name</span>: <span class="string">'helen'</span>&#125;)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对象扩展语法 object spread properties</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  owner: &#123;...preState.owner, &#123;<span class="attr">name</span>: <span class="string">'helen'</span>&#125;&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>react 推荐组件状态不可变的原因在于，返回新对象可以避免原有对象组件状态不小心情况下修改，导致错误，方便管理、调试。还有出于性能考虑，当组件对象不可变时，在组件的 shouldComponentUpdate 方法中仅需要对比前后对象的引用便可以判断是否发迹，避免不必要的 render.</p>
<h2 id="组件与服务器通信"><a href="#组件与服务器通信" class="headerlink" title="组件与服务器通信"></a>组件与服务器通信</h2><ol>
<li><p>组件挂载阶段通信<br>componentDidMount、componentWillUnMount、constructor 应该在这三个生命周期的哪个中与服务器通信呢？</p>
<ul>
<li>constructor 用于初始化组件的 state 以及绑定事件处理等工作，在这里与服务器通信初始化与获取数据后赋值相互污染</li>
<li>componentWillMount 这个方法是组件挂载到 DOM 前调用，且只会调用一次，这个方法中调用 this.setState 不会引起组件重新渲染，虽然 componentWillMount 在 componentDidMount 前执行，但两个重合周期的执行时间差微乎其微。另一种说法，当组件在服务器端渲染时，componentWillMount 会被调用两次，一次服务端，一次浏览器。在 componentWillMount 里面通信，会发送多余的数据请求</li>
<li>componentDidMount 组件挂载到了 Dom，Dom 也已经渲染完成，调用 api 最安全，也是官方推荐与服务器通信的生命周期。可以保证获取到数据时，组件已经挂载到了Dom, 这时直接操作 Dom 也是安全的</li>
</ul>
</li>
<li><p>组件更新阶段通信<br>props 中的某一依据发生变化，这里组件需要重新获取数据更新。componentWillReceiveProps 在 props 引起的组件更新过程中调用。方法参数 nextProps 是父组件传递给当前组件的新的 props. setState 并不会触发 componentWillReceiveProps。</p>
<h2 id="组件通信-1"><a href="#组件通信-1" class="headerlink" title="组件通信"></a>组件通信</h2></li>
<li><p>父子组件通信<br>父子组件间的通信是由 props 完成的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> UserList <span class="keyword">from</span> <span class="string">'./component/UserList'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//... 省略</span></span><br><span class="line">  <span class="comment">// props 将 users 传递给子组件 UserList</span></span><br><span class="line">  handleName(name) &#123;</span><br><span class="line">   <span class="comment">// 调用修改用户信息接口</span></span><br><span class="line">   <span class="comment">// console.log(name)</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;UserList users = &#123;<span class="keyword">this</span>.state.users&#125;&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  modifyName(event) &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; value &#125; = event.target</span><br><span class="line">     <span class="comment">// 子组件通过 props 调用父组件方法</span></span><br><span class="line">      <span class="keyword">this</span>.props.handleName(value)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 返回代表该组件的 ui react 元素</span></span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; users = [] &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">     <span class="keyword">return</span> [</span><br><span class="line">         users.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">           &lt;div key=&#123;item.key&#125;&gt;</span><br><span class="line">             &lt;input value=&#123;item.name&#125; onChange=&#123;<span class="keyword">this</span>.modifyName.bind(<span class="keyword">this</span>)&#125; /&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">         ))</span></span><br><span class="line"><span class="regexp">     ]</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟组件通信</p>
</li>
<li><p>context</p>
</li>
<li><p>延伸</p>
<h2 id="组件的-ref-属性"><a href="#组件的-ref-属性" class="headerlink" title="组件的 ref 属性"></a>组件的 ref 属性</h2></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://helenzhanglp.github.io/2020/11/29/react-component/" data-id="ckmg30lxu0043daw9d94yyvol"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2020/12/02/mock数据/" class="article-nav-link">
        <strong class="article-nav-caption">上一页</strong>
        <div class="article-nav-title">
          
            react + fetch + mockjs
          
        </div>
      </a>
    
    
      <a href="/2020/11/18/浏览器工作原理——Javascript执行机制/" class="article-nav-link">
        <strong class="article-nav-caption">下一页</strong>
        <div class="article-nav-title">浏览器工作原理——浏览器中的Javascript执行机制</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/Javascript">
      var gitalk = new Gitalk({
        clientID: '8e7e6dda81936172806e',
        clientSecret: '97f71b6bbdf731bc650ec39212061882b8f36e71',
        repo: 'blog',
        owner: 'HelenZhangLP',
        admin: ['HelenZhangLP'],
        // id: location.pathname,      // Ensure uniqueness and length less than 50
        id: md5(location.pathname),
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

  gitalk.render('gitalk-container')
  </script>

  

</article>

</section>

  <footer class="footer">
  
  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2021 女魔头</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/HelenZhangLP">HelenZhangLP</a></li>
      <!--
      <li><a href="/">Helen Zhang</a></li>
      -->
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="女魔头"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">档案</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于我</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>

</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>