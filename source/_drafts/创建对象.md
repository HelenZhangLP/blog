---
title: 创建对象
date: 2019-03-21 10:02:40
tags:
- Javascript
- object
---
### Javascript 创建对象
#### 创建字面量(Literal)对象
```Javascript
let myBaby = {
  age: 2,
  name: 'Audrey'
}
```
#### 创建实例对象
```Javascript
let baby = new Object()
baby.name = 'Audrey',
baby.age = 2
```
> 开发过程中实际多采用字面量形式创建对象，但字面量对象避端是`无法复用`，于是就想到了工厂方法

#### 工厂模式
```Javascript
function baby(name, age) {
  return {
    name,
    age
  };
}

let Audrey = baby('Audrey', 2)
let Gulu = baby('Gulu', 2)

Audrey instanceof Baby
// false
Audrey instanceof Object
// true
Object.prototype.toString.call(Audrey)
// {}__proto__: Object
```
#### ** 构造函数 ** 解决对象识别问题
```Javascript
function Baby(name, age) {
  this.name = name;
  this.age = age
}
// new 关键字实例化构造函数
let Audrey = new Baby('Audrey', 2)
Audrey instanceof Baby
// true
/* Baby {name: "Audrey", age: 2}
  age: 2
  name: "Audrey"
    __proto__:
      constructor: ƒ Baby(name, age)
        __proto__: Object */
```
#### ** 构造函数 ** 中引用类型与函数
```Javascript
function Baby(name, age) {
  this.name = name;
  this.age = age;
  this.walk =  function () {
    console.log(this.name + 'is learning to walk')
  }
}
let Audrey = new Baby('Audrey', 2)
let Gulu = new Baby('Gulu', 2)
Audrey.walk()
Gulu.walk()

Audrey.walk == Gulu.walk
// false
```
> 两个对象未指向同一个函数引用，应该是创建了两个函数

#### ** 构造函数 + 原型方法 **
```Javascript
function Baby(name, age) {
  this.name = name;
  this.age = age;
}
Baby.prototype.walk =  function () {
  console.log(this.name + 'is learning to walk')
}
```
> 如上，就能保证引用类型数据独立，方法共享

#### more prototype
