---
title: 构造函数、原型与类
date: 2019-03-21 10:02:40
tags:
- JavaScript
- Object
---

## 构造函数
### JavaScript 创建对象
#### 创建字面量(Literal)对象
```JavaScript
let myBaby = {
  age: 2,
  name: 'Audrey'
}
```
#### 创建实例对象
```JavaScript
let baby = new Object()
baby.name = 'Audrey',
baby.age = 2
```

---
> 开发过程中实际多采用字面量形式创建对象，但字面量对象避端是`无法复用`，于是就想到了工厂方法
#### 工厂模式
```JavaScript
function baby(name, age) {
  return {
    name,
    age
  };
}

let Audrey = baby('Audrey', 2)
let Gulu = baby('Gulu', 2)

Audrey instanceof baby
// false
Audrey instanceof Object
// true
Object.prototype.toString.call(Audrey)
// {}__proto__: Object
```

#### 封装对象建构流程
<font color="#f99">**1.  定义构造函数，解决对象识别问题**`Audrey instanceof Object` 结果true</font>

```JavaScript
function Baby(name, age) {
  this.name = name;
  this.age = age
}
// new 关键字实例化构造函数
let Audrey = new Baby('Audrey', 2)
Audrey instanceof Baby
// true
/* Baby {name: "Audrey", age: 2}
  age: 2
  name: "Audrey"
    __proto__:
      constructor: ƒ Baby(name, age)
        __proto__: Object */
```
> new 关键字 + 函数（函数名以大写字母开头），为封装对象建构的流程的函数称为 **构造函数**
> this 是 new 关键字的实例，构造函数执行结束后，作为结果 return 回去

<font color="#f99">2.   **构造函数 return**</font>

构造函数不需要写 return 语句，如果有写，就返回 return 的值
像 JavaScript 标准 API 中，像 `Number` 即可以当普通函数 `Number('OxFF')` 调用。又可以使用构造函数方式调用 `new Number(OXFF)`。ES6 中，可以使用 **`new.
target`** 检测构造函数中是否明确撰写 return <u>使用 new 构建的实例，new.target 代表了构造函数或类本身；否则就是 undefined</u>

<font color="#f99">3.   **模拟 static**</font>
常量需要仿 static，如 `Math.PI`

### 私有性模拟
JavaScript 没有 private 之类的语法，**可以通过 Closure 模拟**
<font color="#f99">**1. 用 getter 将变量变成构造函数中的局部变量**</font>
```JavaScript
function Account(name, balance) {
    this.getName = () => name;
    this.getBalance = () => balance;
    
    this.getInfo = () => `${name} + ' ' +${balance}`
}

let account = new Account('helen', 3000)
console.log(account.name)   // undefined
console.log(name in account)    // false
```
> 构造函数中，可以通过 `Object.defineProperty()` 定义私有属性
> `Object.defineProperty()` 参数一，接收一个对象；参数二接收想设定的特性名称；参数三是属性描述，采用选项对象的方式来指定属性

```JavaScript
function Account(name,balance) {
    Object.defineProperty(this, 'name', {
        get: () => name
    })；
    Object.defineProperty(this, 'balance', {
        get: () => balance
    })
    this.toString = () => `${this.name}, ${this.balance}`
}
```
> `Object.defineProperties()` 设置多个私有属性

```JavaScript
function Account(name, balance) {
    Object.defineProperties(this, {
        name: {
            get: () => name
        },
        balance: {
            get: () => balance
        }
    })
    
    this.withdraw = (money) => {
        if(money > this.balance) console.warn('sorry, your credit is running low')
        balance -= money
    }
    
    this.toString = () => `${this.name}, ${this.balance}`
}

let account = new Account('helen', 1000)
account.withdraw(500)
account.toString()
```
### 特性描述器
从 ES5 开始，每个特性都由 **value, writable, enumerable, configurable** 4 个特性设定。

|特性|描述|
|---|----|
|value|特性值|
|writable|特性值是否可改|
|enumerable|特性是否可枚举|
|configurable|能否用 `delete` 删除，或用 Object.defineProperty/Object.defineProperties 修改属性|

查询或设定属性时，以上 4 个属性会聚合在对象上，称为特性描述器（Property descriptor）`Object.getOwnPropertyDescriptor() 来取特性描述器信息`

<font color="#f33">`Object.getOwnPropertyDescriptor()` 来设定取特性描述器信息。<u>用`Object.defineProperty()/Object.
defineProperties()` 修改特性本身的属性</u></font>

<font color="#f99">1.   直接对对象新增特性</font>
```JavaScript
let obj = {name: 'helen'}
Object.getOwnPropertyDescriptor(obj, 'name')
```
> {value: "helen", writable: true, enumerable: true, configurable: true}

<font color="#f99">2.   Object.defineProperty 定义特性</font>
```JavaScript
let obj = {}
Object.defineProperty(obj, 'name', {
    value: 'helen'
})
Object.getOwnPropertyDescriptor(obj, 'name')
```
> {value: "helen", writable: false, enumerable: false, configurable: false}

<font color="#f33">***`use strict`+`writable:false` 时，修改变量，引发 TypeError。`use 
strict`+`configurabel:false`时，删除或使用 Object.defineProperty 等修改时，引发 TypeError*** <u>结合以下代码，因为使用 Object.
defineProperty 或 Object.defineProperties 定义的属性，默认 writable: false, enumerable: false, configurable: false 
所以，只有方法可枚举</u></font>
 
```JavaScript
for(let i in account) {
    console.log(i, account[i])
}
{/*VM2619:2 withdraw (money) => {
        if(money > this.balance) console.warn('sorry, your credit is running low')
        balance -= money
    }
VM2619:2 toString () => `${this.name}, ${this.balance}` */}
```
[利用 writable 属性写一个不可叉烧数组，具体代码见 gitHub](https://github.com/HelenZhangLP/demo/blob/draft/js/Base/index.html)

### 扩充、弥封、冻结
## 原型对象
## 类语法


#### ** 构造函数 ** 中引用类型与函数
```JavaScript
function Baby(name, age) {
  this.name = name;
  this.age = age;
  this.walk =  function () {
    console.log(this.name + 'is learning to walk')
  }
}
let Audrey = new Baby('Audrey', 2)
let Gulu = new Baby('Gulu', 2)
Audrey.walk()
Gulu.walk()

Audrey.walk == Gulu.walk
// false
```
> 两个对象未指向同一个函数引用，应该是创建了两个函数

#### ** 构造函数 + 原型方法 **
```JavaScript
function Baby(name, age) {
  this.name = name;
  this.age = age;
}
Baby.prototype.walk =  function () {
  console.log(this.name + 'is learning to walk')
}
```
> 如上，就能保证引用类型数据独立，方法共享

