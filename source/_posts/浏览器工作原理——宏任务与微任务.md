---
title: 浏览器工作原理——宏任务与微任务
date: 2021-01-12 18:48:11
tags:
- browser
- 浏览器工作原理
---


微任务——实时性和效率之间一个有效的权衡
Promise 以及以 Promise 为基础开发出来的其它技术是基于微任务的。

## 宏任务
主线程上的任务包括了渲染事件（如解析 DOM、计算布局、绘制）、用户交互事件（如鼠标、滚动、放大缩小等）、JavaScript 脚本执行、网络请求、文件读写等。
消息队列和事件循环机制协调主线程上的任务执行，渲染进程内部会维护多个消息队列。如延迟队列、普通消息队列等。
消息队列中的任务称为 **宏任务**
WHATWG 规范中对于事件循环机制的定义：
* 先从消息队列中选出一个最老的任务，`oldestTask`；
* 事件循环系统记录任务开始执行的时间，并把 `oldestTask` 设置为当前正在执行的任务；
* 任务完成之后，删除当前正在执行的任务，并从对应的消息队列中删除 `oldestTask`;
* 统计执行完成的时长

宏任务无法处理对时间精度要求较高的任务
<!--more-->
```html
<!DOCTYPE html>
<html>
  <body>
    <div id='demo'>
      <ol>
        <li>test</li>
      </ol>
    </div>
  </body>

  <script type="text/javaScript">
    function timerCallback2() {
      console.log(2)
    }
    function timerCallback1() {
      console.log(1)
      setTimeout(timerCallback2, 0)
    }
    setTimeout(timerCallback1, 0)
  </script>
</html>
```
![img](https://static001.geekbang.org/resource/image/3c/15/3c2b9b474c4df544df61ebd62a7b3715.png)
setTimeout 函数触发的回调函数都是宏任务，图中渲染引擎将一些系统级任务（图中粉色区域）手入到了两个定时任务中间。如果中间系统级任务处理时间过长，会影响后面一个定时任务执行。宏任务时间粒度大，执行时间间隔是不能精确控制的，对一些高实时性的需求不符合。setTimeout 和 XMLHttpRequest 被添加在宏任务中。

## 微任务
`异步回调的两种方式`：
1.  把回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数
2.  执行时机是主函数执行结束之后、当前宏任务结束之前执行回调函数，通常是以微任务形式体现

> 微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前

每个宏任务都关联一个微任务队列

### 微任务产生的时机和执行微任务队列的时机
现代浏览器中产生微任务有两种方式：
1.  使用 MutationObserver 监控 DOM 节点，然后再通过 JavaScript 来修改节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务
2.  使用 Promise，当调用 Promise.resolve() 或 Promise.reject() 产生微任务

通过 DOM 节点变化产生的微任务或使用 Promise 产生的微任务都被 JavaScript 引擎按照顺序保存到微任务列表

微任务队列是何时被执行的？
通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就是 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检测全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
**WHATWG 把执行微任务的时间点称为检查点**

如果在执行微任务的过程中，产生新微任务，同样会将该微任务添加到微任务队列中。V8 引擎一直循环执行微任务队列中的任务，直到队列为空。也就是说在执行微任务的过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

`微任务示意图`:
{%plantuml%}
skinparam componentStyle rectangle
card 宏任务 {
  component parseHTML #66F
  component EvaluateScript #66f
  component 执行上下文 {
    component 微任务队列 #fee {
      component Mutation #f66
      component Promise #f66
    }
  }
  component "Promise.resolve()" as resolve #66F
  component removeChild #66f

  resolve --> 微任务队列
  removeChild --> 微任务队列
}

card 宏任务 as task2 {
  component parseHTML as parseHTML2 #66F
  component EvaluateScript as EvaluateScript2 #66f
  component 执行上下文 as context {
    component 微任务队列 as tasklist #fee {
      component Mutation as mutation1 #f66
      component Promise as Promise1 #f66
    }
  }
}

宏任务 --> task2: JavaScript 脚本执行结束，准备退出全局执行上下文
{%endplantuml%}

{%plantuml%}
skinparam componentStyle rectangle
card 宏任务 {
  component parseHTML #66F
  component EvaluateScript #66f
  component 执行上下文 {
    component 微任务队列 #fee {
      component Mutation #f66
    }
  }
  component "resolve(1)" as resolve #66F
  微任务队列 --> resolve : Promise 取出 Promise 在当前宏任务中执行
}

card 宏任务 as task1 {
  component parseHTML as parseHTML1 #66F
  component EvaluateScript as EvaluateScript1 #66f
  component 执行上下文 as 执行上下文1 {
    component 微任务队列 as 微任务队列1 #fee {
    }
  }
  component "resolve(1)" as resolve1 #66F
  微任务队列1 --> resolve1 : Mutation 取出 Mutation 在当前宏任务中执行
}

{%endplantuml%}
在执行 parseHTML 宏任务时，遇到了 JavaScript 脚本，那么暂停 parseHTML，进入到 JavaScript 的执行环境。在 JavaScript 脚本执行过程中，通过 Promise 和 removeChild 创建了两个微任务，并被添加到了微任务列表（从图中看出，微任务队列在执行上下文中）JavaScript 执行结束，准备退出全局执行上下文，进入检查点，JavaScript 引擎检查微任务列表，发现列表中有微任务，依次执行微任务，任务队列清空后，退出全局执行上下文。

关于微任务、宏任务的几点结论：
1.  微任务和宏任务绑定，每个宏任务执行都会创建自己的微任务队列
2.  微任务的执行时长影响到当前宏任务的执行时长。如一个宏任务产生了 100 个微任务，每个微任务执行时长 10 毫秒，那么宏任务被延长了 1秒钟。写代码时要注意控制微任务时长
3.  在一个宏任务中，分别创建了用于回调的宏任务和微任务，无论什么情况，微任务都早于宏任务执行

## 监听DOM变化方法演变
MutationObserver 是用来监听 DOM 变化的一套方法
web 应用需要监听 DOM 变化并及时地做出响应

早期要观察 DOM 是否变化，唯一能做的就是轮询检测，如使用 setTimeout 或者 setInterval 定时检测 DOM 是否变化。
这种方法简单粗暴，而且会遇到两个问题：
如果时间间隔设置过长，DOM 变化响应不够及时
相反，如果时间间隔设置过短，会浪费无用的工作量检查 DOM，让页面变得低效

**Mutation Event** 采用了 **观察者设置模式** 当DOM 有变化时就立即触发相应的事件，这种方式属于同步回调
Mutation Event 解决了实时性的问题，DOM 一旦发生变化，立即调用 javaScript 接口。这种实时性造成了严重的性能问题，每次 DOM 变化，渲染引擎会调用 javaScript 会产生较大的性能开销。比如利用 javaScript 动态创建 50 个节点，会触发 50 次回调，若每次回调执行时 2ms，500 次是 200ms ，如果是一个动画执行，Mutation Event 触发回调会导致动画卡顿

**DOM4 开始，推荐使用 MutationObserver 替代 Mutation Event** MutationObserver API 用来监视 DOM 变化
MutationObserver 将 Mutation Event DOM 变化触发的同步回调改为异步回调，多次 DOM 变化时触发一次异步回调，并且用一个数据结构记录这期间所有 DOM 的变化。这样即使频繁地操纵 DOM 也不会造成太大的影响。

异步 + 减少调用次数缓解性能问题，实时性的问题则交给微任务，在每次 DOM 节点发生变化时，渲染引擎将变化记录封装成，并将微任务添加到队列中。当执行到检查点时，V8 引擎会按照顺序执行微任务
