---
title: 浏览器工作原理——消息队列与事件循环
date: 2021-01-08 10:39:50
tags:
- browser
---

## 线程模型（一）
有确定好的任务，使用一个单线程来按顺序处理任务
```javaScript
var a = 1 + 2; // task1
var b = 2 + 3; // task2
var c = 3 + 4; // task3

console.log(a, b, c) // task4
```
> 使用单线程处理已知任务 task1 task2 task3 task4

{%plantuml%}
title 线程
hide footbox

boundary 开始线程 as start
participant task1
participant task2
participant task3
participant task4
boundary 线程退出 as end
start-->task1
task1-->task2
task2-->task3
task3-->task4
task4-->end

{%endplantuml%}

<!--more-->

## 线程模型（二）
引入 **循环语句** 和 **事件系统**，在线程执行过程中接收并处理新任务。
> 采用事件循环机制，在线程运行过程中接收并执行新任务
  1.  主线程中 **引入循环机制**，即在线程语句加入 for 循环，线程会一直循环执行；
  2.  **引入事件**,如在线程运行过程中，等待用户输入，线程暂停，接收到用户输入后，线程激活，继续执行。

{%plantuml%}
title 线程模型采用事件机制，接收并执行新任务
hide footbox

boundary 线程 as startEnd
control "for(;;)" as control
startEnd --> control: 初始化线程
control --> startEnd: 接收任务并继续执行
{%endplantuml%}

## 线程模型（三）
引入 **消息队列** 接收其它线程发送过来的任务。
{%plantuml%}
title 渲染进程
card 主线程 as mainThread

card IO线程 as IOThread {
  0 ..>mainThread: 资源加载完成事件
  1 ..>mainThread: 鼠标点击事件
  2 ..>mainThread: 其它事件
}

{%endplantuml%}

使用消息队列管理IO线程传递的任务，队列先进行出，任务添加在队列尾部，从头部取出

{%plantuml%}
title 渲染进程
skinparam component {
  backgroundColor #599989
}
skinparam rectangle {
  backgroundColor #339945
}

rectangle "主线程" {
  left to right direction
  boundary 线程 as startEnd
  control "for(;;)执行任务" as control
  control == startEnd
}

component 消息队列 {
   component 任务2 {
}
   component 任务1 {
}
   component 任务N
   [任务...]
}

任务1 --> control

card IO线程 as IOThread {
  0 ..>任务N: 资源加载完成事件
  1 ..>任务N: 鼠标点击事件
  2 ..>任务N: 其它事件
}
{%endplantuml%}
其它线程想要发送任务让主线程执行，只需要将任务添加到消息队列中就可以了。由于多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加一个同步锁。

## 线程模型（四）—— 处理其它进程发送过来的任务
如果其它线程想要发送任务给页面主线程，那么需要先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。
{%plantuml%}
title 渲染进程
skinparam component {
  backgroundColor #599989
}
skinparam rectangle {
  backgroundColor #339945
}

rectangle "主线程" {
  left to right direction
  boundary 线程 as startEnd
  control "for(;;)执行任务" as control
  control == startEnd
}

component 消息队列 {
   component 任务2 {
}
   component 任务1 {
}
   component 任务N
   [任务...]
}

任务1 --> control

card IO线程 as IOThread {
  0 ..>任务N: 资源加载完成事件
  1 ..>任务N: 鼠标点击事件
  2 ..>任务N: 其它事件
}

[网络进程]
[浏览器进程]

网络进程 --> IOThread: IPC 资源加载完成
浏览器进程 --> IOThread: IPC 鼠标点击
{%endplantuml%}

渲染进程专门有一个IO线程用来接收其它线程传进来的消息，IO线程会将这些消息组装成任务发送给渲染主线程

## 消息队列中的任务类型
输入事件（鼠标事件）、微任务、文件读写、WebSocket、javaScript定时器等
消息队列中还包含了很多与页面相关的事件，如：javaScript 执行、解析 DOM、样式计算、布局计算、css 动画等
> 以上事件是在主线程中执行的，所以在编写 web 应用程序时，需要衡量这些事件所占用的时长、并解决单个任务占用主线程过久的问题。

## 主线程如何安全退出
chrome 确定退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否设置退出标志。如果有，直接中断所有任务，退出线程。

## 页面中使用单线程的缺点——微任务解决效率和实时性问题
1.  如何处理高优先级的任务
在处理监听 DOM 节点变化，根据这些变化处理相应的业务逻辑场景中。通常是采用观察者模式（利用 javaScript 设计监听接口，当变化发生时，渲染引擎同步调用这些接口）
问题在于，DOM 变化非常频繁，每次变化都调用直接调用相应 javaScript 接口，那么当前任务执行时间拉长，导致执行效率下降。
如果将 DOM 变化做成异步消息事件，添加到消息队列尾部，又会影响到监控的实时性。
### 微任务用来权衡实时性与效率，微任务如何权衡效率与实时性的
> 消息队列中的任务称为宏任务，每个宏任务中都包含一个微任务队列。

在执行宏任务中，DOM 有变化，那么就会将变化添加到微任务列表中，这样就不会影响到宏任务的执行。解决了执行效率问题。
当前宏任务执行完成，执行当前宏任务的微任务（DOM 变化的事件都保存在微任务列表中），从而解决了实时性的问题。

2.  如何解决单个任务执行过久的问题
javaScript 通过回调功能解决单个任务执行过久，造成后面任务等待时间太长，给用户卡顿的感觉。

## 浏览器如何运行的
开发者工具 --> performance 标签 --> 右上角 start porfiling and load page
